load("@bazel_skylib//rules:build_test.bzl", "build_test")
load("@bazel_skylib//rules:copy_directory.bzl", "copy_directory")
load("@bazel_skylib//rules:write_file.bzl", "write_file")
load("@rules_img//img:image.bzl", "image_index", "image_manifest")
load("@rules_img//img:layer.bzl", "file_metadata", "image_layer")
load("@rules_img//img:push.bzl", "image_push")
load("@rules_img_images.bzl", "image")
load("@rules_pkg//pkg:tar.bzl", "pkg_tar")
load("@rules_shell//shell:sh_binary.bzl", "sh_binary")
load(":bzl/gen_link.bzl", "gen_dir_link")

# Test files for various scenarios
write_file(
    name = "empty_file",
    out = "empty.txt",
    content = [],
)

write_file(
    name = "large_file",
    out = "large.txt",
    content = ["line %d\n" % i for i in range(1000)],
)

write_file(
    name = "binary_file",
    out = "binary.dat",
    content = ["\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07"],
    is_executable = False,
)

write_file(
    name = "executable_script",
    out = "script.sh",
    content = ["#!/bin/bash\necho 'Hello World'\n"],
    is_executable = True,
)

copy_directory(
    name = "tree_artifact_source",
    src = "some_directory",
    out = "tree_artifact",
)

gen_dir_link(
    name = "link",
    target_compatible_with = select({
        "@platforms//os:windows": ["@platforms//:incompatible"],
        "//conditions:default": [],
    }),
)

sh_binary(
    name = "executable_script_with_runfiles",
    srcs = ["script.sh"],
    data = [":link"],
)

write_file(
    name = "unicode_file",
    out = "unicode.txt",
    content = [
        "Hello ‰∏ñÁïå\n",
        "„Åì„Çì„Å´„Å°„ÅØ\n",
        "üöÄüéâ\n",
    ],
)

# This tar file consists of only NULL bytes (end-of-file marker for tar)
pkg_tar(
    name = "empty_tar",
    srcs = [],
)

image_manifest(
    name = "image_with_empty_uncompressed_tar_layer",
    base = image("nginx"),
    layers = [":empty_tar"],
)

# Edge case: Source directory
image_layer(
    name = "src_dir_layer",
    srcs = {"deep": ":deep_structure"},
    target_compatible_with = select({
        # TODO: Inspect why Windows has issues with directory layers
        "@platforms//os:windows": ["@platforms//:incompatible"],
        "//conditions:default": [],
    }),
)

# Edge case: Empty layer
image_layer(
    name = "empty_layer",
    srcs = {},
)

# Edge case: Layer with only empty files
image_layer(
    name = "empty_files_layer",
    srcs = {
        "empty1.txt": ":empty_file",
        "empty2.txt": ":empty_file",
    },
)

# Edge case: Layer with mixed file types
image_layer(
    name = "mixed_layer",
    srcs = {
        "bin/script": ":executable_script",
        "data/large.txt": ":large_file",
        "data/binary.dat": ":binary_file",
        "data/unicode.txt": ":unicode_file",
        "empty.txt": ":empty_file",
    },
    symlinks = {
        "script_link": "/bin/script",
        "data_link": "/data",
    },
)

# Edge case: Layer with symlinks in runfiles
image_layer(
    name = "symlinks_layer",
    srcs = {
        "bin/script": ":executable_script_with_runfiles",
    },
)

# Edge case: Layer with tree artifact
image_layer(
    name = "tree_artifact_layer",
    srcs = {
        "a_directory": ":tree_artifact_source",
        "some_other/nested_path": ":tree_artifact_source",
    },
)

# Edge case: Layer with deeply nested paths
image_layer(
    name = "deep_paths_layer",
    srcs = {
        "very/deeply/nested/directory/structure/file.txt": ":large_file",
        "a/b/c/d/e/f/g/h/i/j/deep.txt": ":unicode_file",
    },
)

# Edge case: Layer with special characters in paths
image_layer(
    name = "special_chars_layer",
    srcs = {
        "file with spaces.txt": ":large_file",
        "file-with-dashes.txt": ":binary_file",
        "file_with_underscores.txt": ":unicode_file",
        "file.with.dots.txt": ":empty_file",
    },
)

# Edge case: Layer with file metadata (testing the new feature)
image_layer(
    name = "metadata_layer",
    srcs = {
        "bin/app": ":executable_script",
        "etc/config.txt": ":large_file",
        "tmp/temp.txt": ":unicode_file",
    },
    default_metadata = file_metadata(
        gid = 1000,
        mode = "0644",
        uid = 1000,
    ),
    file_metadata = {
        "bin/app": file_metadata(
            gid = 0,
            mode = "0755",
            uid = 0,
        ),
        "tmp/temp.txt": file_metadata(mode = "0666"),
    },
)

# Edge case: Single layer manifest
image_manifest(
    name = "single_layer_manifest",
    layers = [":mixed_layer"],
)

image_push(
    name = "push_single_layer",
    image = ":single_layer_manifest",
    registry = "ghcr.io",
    repository = "malt3/rules_img/e2e-generic-single-layer",
    visibility = ["//visibility:public"],
)

# Edge case: Multi-layer manifest with different types
image_manifest(
    name = "multi_layer_manifest",
    entrypoint = ["/bin/script"],
    env = {
        "PATH": "/bin:/usr/bin",
        "HOME": "/root",
        "EMPTY_VAR": "",
        "SPECIAL_CHARS": "hello world & friends",
    },
    labels = {
        "version": "1.0.0",
        "maintainer": "test@example.com",
        "description": "Test image with edge cases",
        "empty_label": "",
        "special.label": "value-with-special_chars.123",
    },
    layers = [
        ":empty_layer",
        ":empty_files_layer",
        ":mixed_layer",
        ":deep_paths_layer",
        ":special_chars_layer",
    ],
)

image_push(
    name = "push_multi_layer",
    image = ":multi_layer_manifest",
    registry = "ghcr.io",
    repository = "malt3/rules_img/e2e-generic-multi-layer",
    visibility = ["//visibility:public"],
)

# Edge case: Manifest with extensive annotations
image_manifest(
    name = "annotated_manifest",
    annotations = {
        "org.opencontainers.image.title": "Test Image",
        "org.opencontainers.image.description": "A test image for rules_img edge cases",
        "org.opencontainers.image.version": "1.0.0-test",
        "org.opencontainers.image.created": "2023-01-01T00:00:00Z",
        "custom.annotation": "custom value",
        "empty.annotation": "",
        "special/annotation": "value with / and spaces",
    },
    layers = [":mixed_layer"],
)

image_push(
    name = "push_annotated",
    image = ":annotated_manifest",
    registry = "ghcr.io",
    repository = "malt3/rules_img/e2e-generic-annotated",
    visibility = ["//visibility:public"],
)

# File containing annotations (one KEY=VALUE per line)
write_file(
    name = "manifest_annotations_file",
    out = "manifest_annotations.txt",
    content = [
        "org.opencontainers.image.source=https://github.com/bazel-contrib/rules_img",
        "org.opencontainers.image.revision=abc123",
        "custom.build.number=42",
        "custom.environment=test",
    ],
)

# Edge case: Manifest with annotations from file
image_manifest(
    name = "manifest_with_annotations_file",
    annotations_file = ":manifest_annotations_file",
    layers = [":mixed_layer"],
)

# Edge case: Manifest with both inline annotations and annotations_file
image_manifest(
    name = "manifest_with_merged_annotations",
    annotations = {
        "inline.annotation": "inline value",
        "org.opencontainers.image.title": "Test Image",
    },
    annotations_file = ":manifest_annotations_file",
    layers = [":mixed_layer"],
)

# Edge case: Multi-platform image index
image_index(
    name = "multi_platform_index",
    manifests = [
        ":single_layer_manifest",
        ":multi_layer_manifest",
        ":annotated_manifest",
    ],
)

image_push(
    name = "push_index",
    image = ":multi_platform_index",
    registry = "ghcr.io",
    repository = "malt3/rules_img/e2e-generic-index",
    visibility = ["//visibility:public"],
)

# File containing index annotations
write_file(
    name = "index_annotations_file",
    out = "index_annotations.txt",
    content = [
        "org.opencontainers.image.ref.name=multiarch",
        "custom.index.version=1.0",
    ],
)

# Edge case: Image index with annotations from file
image_index(
    name = "index_with_annotations_file",
    annotations_file = ":index_annotations_file",
    manifests = [
        ":single_layer_manifest",
        ":multi_layer_manifest",
    ],
)

# Edge case: Image index with both inline annotations and annotations_file
image_index(
    name = "index_with_merged_annotations",
    annotations = {
        "inline.index.annotation": "inline value",
    },
    annotations_file = ":index_annotations_file",
    manifests = [
        ":single_layer_manifest",
        ":multi_layer_manifest",
    ],
)

# Edge case: Layer with many annotations
image_layer(
    name = "heavily_annotated_layer",
    srcs = {"test.txt": ":large_file"},
    annotations = {
        "layer.type": "application",
        "layer.version": "1.0",
        "layer.size": "large",
        "layer.compressed": "true",
        "custom.annotation.1": "value1",
        "custom.annotation.2": "value2",
        "custom.annotation.3": "value3",
        "custom.annotation.4": "value4",
        "custom.annotation.5": "value5",
    },
)

# File containing layer annotations
write_file(
    name = "layer_annotations_file",
    out = "layer_annotations.txt",
    content = [
        "org.opencontainers.image.authors=rules_img team",
        "layer.build.tool=bazel",
        "layer.optimized=true",
    ],
)

# Edge case: Layer with annotations from file
image_layer(
    name = "layer_with_annotations_file",
    srcs = {"data.txt": ":large_file"},
    annotations_file = ":layer_annotations_file",
)

# Edge case: Layer with both inline annotations and annotations_file
image_layer(
    name = "layer_with_merged_annotations",
    srcs = {"data.txt": ":unicode_file"},
    annotations = {
        "inline.layer.annotation": "inline value",
        "layer.priority": "high",
    },
    annotations_file = ":layer_annotations_file",
)

# Edge case: Manifest with complex configuration
image_manifest(
    name = "complex_manifest",
    cmd = [
        "arg1",
        "arg2",
        "arg3",
    ],
    entrypoint = [
        "/bin/app",
        "--flag1",
        "--flag2=value",
    ],
    env = {
        "VAR1": "value1",
        "VAR2": "value2",
        "PATH": "/custom/bin:/bin:/usr/bin",
        "LANG": "en_US.UTF-8",
        "TZ": "UTC",
    },
    labels = {
        "app.name": "test-app",
        "app.version": "1.0.0",
        "app.component": "backend",
        "build.timestamp": "2023-01-01T12:00:00Z",
        "build.commit": "abc123def456",
    },
    layers = [
        ":heavily_annotated_layer",
        ":metadata_layer",
    ],
    user = "1000:1000",
    working_dir = "/app",
)

image_push(
    name = "push_complex",
    image = ":complex_manifest",
    registry = "ghcr.io",
    repository = "malt3/rules_img/e2e-generic-complex",
    visibility = ["//visibility:public"],
)

# Edge case: Manifest with created timestamp
write_file(
    name = "created_timestamp",
    out = "created.txt",
    content = ["2024-01-15T10:30:00Z"],
)

image_manifest(
    name = "manifest_with_created",
    created = ":created_timestamp",
    entrypoint = ["/bin/script"],
    labels = {
        "description": "Test image with created timestamp",
    },
    layers = [":mixed_layer"],
)

image_push(
    name = "push_with_created",
    image = ":manifest_with_created",
    registry = "ghcr.io",
    repository = "malt3/rules_img/e2e-generic-with-created",
    visibility = ["//visibility:public"],
)

# File containing multiple tags (one per line)
write_file(
    name = "push_tags_file",
    out = "push_tags.txt",
    content = [
        "v1.0.0",
        "v1.0",
        "stable",
    ],
)

# Test push with tag_file
image_push(
    name = "push_tag_file",
    image = ":single_layer_manifest",
    registry = "ghcr.io",
    repository = "malt3/rules_img/e2e-generic-tag-file",
    tag_file = ":push_tags_file",
    visibility = ["//visibility:public"],
)

# Build tests to ensure all targets can be built
build_test(
    name = "layer_tests",
    targets = [
        ":empty_layer",
        ":empty_files_layer",
        ":mixed_layer",
        ":deep_paths_layer",
        ":special_chars_layer",
        ":metadata_layer",
        ":heavily_annotated_layer",
        ":layer_with_annotations_file",
        ":layer_with_merged_annotations",
    ],
)

build_test(
    name = "manifest_tests",
    targets = [
        ":single_layer_manifest",
        ":multi_layer_manifest",
        ":annotated_manifest",
        ":manifest_with_annotations_file",
        ":manifest_with_merged_annotations",
        ":complex_manifest",
        ":manifest_with_created",
        ":manifest_extending_gcr_base",
    ],
)

build_test(
    name = "index_tests",
    targets = [
        ":multi_platform_index",
        ":index_with_annotations_file",
        ":index_with_merged_annotations",
    ],
)

build_test(
    name = "push_tests",
    targets = [
        ":push_single_layer",
        ":push_multi_layer",
        ":push_annotated",
        ":push_index",
        ":push_complex",
        ":push_with_created",
        ":push_tag_file",
        ":push_gcr_based",
    ],
)

# Test: Platform transition feature using target platform
image_manifest(
    name = "manifest_with_target_platform_arm64",
    entrypoint = ["/bin/script"],
    labels = {
        "architecture": "arm64",
        "test": "platform_transition",
    },
    layers = [":mixed_layer"],
    platform = "//platform:linux_arm64",
)

image_manifest(
    name = "manifest_with_target_platform_amd64",
    entrypoint = ["/bin/script"],
    labels = {
        "architecture": "amd64",
        "test": "platform_transition",
    },
    layers = [":mixed_layer"],
    platform = "//platform:linux_amd64",
    visibility = ["//visibility:public"],
)

# Create index from platform-transitioned manifests
image_index(
    name = "platform_transitioned_index",
    manifests = [
        ":manifest_with_target_platform_arm64",
        ":manifest_with_target_platform_amd64",
    ],
    visibility = ["//visibility:public"],
)

build_test(
    name = "platform_transition_tests",
    targets = [
        ":manifest_with_target_platform_arm64",
        ":manifest_with_target_platform_amd64",
        ":platform_transitioned_index",
    ],
)

# Test: Using GCR image pulled by tag as base
# This demonstrates the unsafe_allow_tag_without_digest feature
image_layer(
    name = "app_layer_for_gcr",
    srcs = {
        "/app/script.sh": ":executable_script",
        "/app/data.txt": ":large_file",
    },
)

image_manifest(
    name = "manifest_extending_gcr_base",
    base = "@distroless_base_gcr//:image",
    entrypoint = ["/app/script.sh"],
    labels = {
        "base.pulled.by": "tag-without-digest",
        "test": "gcr_tag_pull",
    },
    layers = [":app_layer_for_gcr"],
)

image_push(
    name = "push_gcr_based",
    image = ":manifest_extending_gcr_base",
    registry = "ghcr.io",
    repository = "malt3/rules_img/e2e-generic-gcr-based",
    visibility = ["//visibility:public"],
)

build_test(
    name = "all_tests",
    targets = [
        ":layer_tests",
        ":manifest_tests",
        ":index_tests",
        ":push_tests",
        ":platform_transition_tests",
    ],
)
