module(name = "generic_e2e")

# BEGIN BAZEL_DEP
bazel_dep(name = "rules_img")
local_path_override(
    module_name = "rules_img",
    path = "../..",
)

bazel_dep(name = "rules_img_pull_tool")
local_path_override(
    module_name = "rules_img_pull_tool",
    path = "../../pull_tool",
)

bazel_dep(name = "rules_img_tool")
local_path_override(
    module_name = "rules_img_tool",
    path = "../../img_tool",
)

register_toolchains("@rules_img_tool//toolchain:all")
# END BAZEL_DEP

bazel_dep(name = "bazel_skylib", version = "1.7.1")
bazel_dep(name = "container_structure_test", version = "1.22.1")
bazel_dep(name = "platforms", version = "0.0.11")
bazel_dep(name = "rules_distroless", version = "0.6.1")
bazel_dep(name = "rules_pkg", version = "1.1.0")
bazel_dep(name = "rules_python", version = "1.7.0")
bazel_dep(name = "rules_shell", version = "0.6.1")
bazel_dep(name = "tar.bzl", version = "0.7.0")

single_version_override(
    module_name = "rules_distroless",
    patch_strip = 1,
    patches = ["//custom_distroless_base_image:rules_distroless.patch"],
)

# Configure apt for Debian packages
apt = use_extension("@rules_distroless//apt:extensions.bzl", "apt")

# Configure Debian Bookworm packages
apt.install(
    name = "bookworm",
    lock = "//custom_distroless_base_image:apt.lock.json",
    manifest = "//custom_distroless_base_image:apt.yaml",
)
use_repo(apt, "bookworm")

# Configure Python and pip
python = use_extension("@rules_python//python/extensions:python.bzl", "python")
python.toolchain(
    python_version = "3.13",
)
use_repo(python, "python_3_13")

pip = use_extension("@rules_python//python/extensions:pip.bzl", "pip")
pip.parse(
    download_only = True,
    hub_name = "pip",
    python_version = "3.13",
    requirements_lock = "//integrationtest/testcontainers:requirements_lock.txt",
)
use_repo(pip, "pip")

# Pull Alpine Linux as base image
pull = use_repo_rule("@rules_img//img:pull.bzl", "pull")

pull(
    name = "alpine",
    digest = "sha256:51183f2cfa6320055da30872f211093f9ff1d3cf06f39a0bdb212314c5dc7375",
    layer_handling = "lazy",
    registries = [
        "mirror.gcr.io",
        "index.docker.io",
    ],
    repository = "library/alpine",
    tag = "3.23",
)

pull(
    name = "cuda",
    digest = "sha256:198208c45877a84c8fb35a06956e7fbef4ffabfa36f9c82148dc7bac454ba02a",
    registries = [
        "mirror.gcr.io",
        "index.docker.io",
    ],
    repository = "nvidia/cuda",
    tag = "13.0.0-tensorrt-runtime-ubuntu24.04",
)

# image that contains a manifest without explicit mediaType field
pull(
    name = "envoy",
    digest = "sha256:d68fc27a15a17ae3b13df8c8631523a2fe1192b39ec867dffe870b666c55c2dd",
    repository = "envoyproxy/envoy",
    tag = "v1.36.3",
)

pull(
    name = "neo4j",
    digest = "sha256:5bd040cfe84b953a893c943cf3be4e4dc3b2758c154c192a6196de9d1e31b11b",
    layer_handling = "lazy",
    registry = "index.docker.io",
    repository = "library/neo4j",
    tag = "5.26.18-ubi9",
)

# Example of pulling from GCR by tag without digest
# This uses the new unsafe_allow_tag_without_digest flag
# which is useful when you're managing reproducibility through content-based tags
pull(
    name = "distroless_base_gcr",
    layer_handling = "lazy",
    registry = "gcr.io",
    repository = "distroless/base-debian12",
    tag = "latest",
    unsafe_allow_tag_without_digest = True,
)

pull(
    name = "distroless_static",
    digest = "sha256:3f2b64ef97bd285e36132c684e6b2ae8f2723293d09aae046196cca64251acac",
    layer_handling = "eager",
    registry = "gcr.io",
    repository = "distroless/static",
)

pull(
    name = "nanoserver",
    digest = "sha256:4bfc3ec32a8b9bb5e7a182440c517b0706267d88fda77b54acddf819920400ad",
    registry = "mcr.microsoft.com",
    repository = "windows/nanoserver",
)

images = use_extension("@rules_img//img:extensions.bzl", "images")
images.pull(
    name = "nginx",
    digest = "sha256:029d4461bd98f124e531380505ceea2072418fdf28752aa73b7b273ba3048903",
    registries = [
        "mirror.gcr.io",
        "index.docker.io",
    ],
    repository = "library/nginx",
)
images.settings(
    hub_repo = "enabled",
    image_repos = "enabled",
)
use_repo(images, "rules_img_images.bzl", nginx = "img_029d4461bd98f124e531380505ceea2072418fdf28752aa73b7b273ba3048903")
